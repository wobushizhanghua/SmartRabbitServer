#include "rpc.h"
#include "svr_connection.h"
#include "player.h"
#include "twice_login.h"
#include "../rbtlib/open_login.h"

static int serv_reg(rabbit * r, Connection * c, Packet * pkt)
{
	rbtP_seek(pkt, 0);
	int key, id;
	if(rbtP_readInt(pkt, &key) < 0) {
		kLOG(r, 0, "[Error]逻辑服务器注册出错！缺少Key！\n");
		return -1;
	}
	if(key != G(r)->key) {
		kLOG(r, 0, "[Error]逻辑服务器注册出错！Key(%x != %x)错误！\n", key, G(r)->key);
		return -1;
	}
	if(rbtP_readInt(pkt, &id) < 0) {
		kLOG(r, 0, "[Error]逻辑服务器注册出错！缺少 ID！\n");
		return -1;
	}
	if(id < 0 || id >= LOGICAL_SERVER_MAX_NUM) {
		kLOG(r, 0, "[Error]逻辑服务器注册出错！ID(%d) 出错！Max:%d\n", id, LOGICAL_SERVER_MAX_NUM);
		return -1;
	}
	short int req_id;
	if(rbtP_readShort(pkt, &req_id) < 0) {
		kLOG(r, 0, "[Error]逻辑服务器注册出错！ID(%d) 缺少req_id！\n", id);
		return -1;
	}

	struct LogicalServer * serv = &G(r)->servs[id];
	if(serv->id > 0 || serv->c) {
		kLOG(r, 0, "[Error]逻辑服务器(%d)注册重复！把之前的断开！！\n", id);
		rbtRpc_call(r, NULL, serv->c, SERV_FOR_CONN_REG_AGAIN, "");
		// 将Group和PlayerList直接复用
	} else {
		list_init(&serv->player_list);
		serv->nuser = 0;
		serv->groups = rbtH_init(r, 0, 0);
		rbtH_weak(serv->groups);
	}

	rbtNet_set_authed(c, 1);

	struct ConnectionX * connX = rbtNet_get_x(c);
	connX->a1 = CONN_SERV;
	connX->a2 = id;

	serv->id = id;
	serv->c = c;

	serv->broadcast = array_create(r, sizeof(struct GlobalMessage), 16);
	serv->nbroadcast = 0;

	gettimeofday(&serv->come_tm, NULL);

	rbtStat_init(r, &serv->stat);

	rbtRpc_ret(r, c, req_id, "d", 1);

	return 0;
}

static int admin_reg(rabbit * r, Connection * c, Packet * pkt)
{
	rbtP_seek(pkt, 0);
	int key;
	if(rbtP_readInt(pkt, &key) < 0) {
		kLOG(r, 0, "[Error]Admin服务器注册出错！缺少Key！\n");
		return -1;
	}
	if(key != G(r)->key) {
		kLOG(r, 0, "[Error]Admin服务器注册出错！Key(%x != %x)错误！\n", key, G(r)->key);
		return -1;
	}
	short int req_id;
	if(rbtP_readShort(pkt, &req_id) < 0) {
		kLOG(r, 0, "[Error]Admin服务器注册出错！缺少Req id！\n");
		return -1;
	}

	kLOG(r, 0, "[LOG]Admin 服务器注册成功！\n");

	rbtNet_set_authed(c, 1);

	struct ConnectionX * connX = rbtNet_get_x(c);
	connX->a1 = CONN_ADMIN;

	G(r)->admin = c;

	rbtRpc_ret(r, c, req_id, "d", 1);

	return 0;
}

static int client_login(rabbit * r, Connection * c, Packet * pkt)
{
	rbtP_seek(pkt, 0);
	int account, zone_id;
	TString * session;
	
	if(rbtP_readString(pkt, &session) < 0) {
		kLOG(r, 0, "[Error]玩家登陆出错！缺少Session！ip:%s, port:%d\n", rbtNet_ip(c), rbtNet_port(c));
		return -1;
	}
	if(rbtP_readInt(pkt, &account) < 0) {
		kLOG(r, 0, "[Error]玩家登陆出错！缺少Account！ip:%s, port:%d\n,", rbtNet_ip(c), rbtNet_port(c));
		return -1;
	}
	if(rbtP_readInt(pkt, &zone_id) < 0) {
		kLOG(r, 0, "[Error]玩家登陆出错！缺少ZoneID！ip:%s, port:%d\n", rbtNet_ip(c), rbtNet_port(c));
		return -1;
	}

	// 验证...

	int v_account = get_account_from_open_ticket( (unsigned char*)(rbtS_gets(session)) );

	//char * result = (char*)login_decode_ticket((unsigned char *)(rbtS_gets(session)), rbtS_len(session), &out_len);
	if( !v_account ) {
		// 验证失败！
		kLOG(r, 0, "[LOG]玩家登录验证失败！Session(%s), Account(%d) ZoneID(%d), ip:%s, port:%d\n", rbtS_gets(session), account, zone_id, rbtNet_ip(c), rbtNet_port(c));
		return -1;
	}

	if( v_account != account) {
		// 验证成功，但账号不对
		kLOG(r, 0, "[LOG]玩家登陆，验证成功，但是账号不对？(%d) != (%d), ip:%s, port:%d\n", account, v_account, rbtNet_ip(c), rbtNet_port(c));
		return -1;
	}

	rbtNet_set_authed(c, 1);
	rbtNet_set_encode(c, 1);

	rbtF_player_login(r, c, account, zone_id);

	return 0;
/*
	struct Player * ply = rbtF_player_get_account(r, account);
	if(ply) {
		// 2次登录，断开之前的 
		kLOG(r, 0, "[LOG]玩家登陆,(Account:%d)2次登录，断开原来的链接！ip:%s, port:%d\n", account, rbtNet_ip(c), rbtNet_port(c));
		rbtF_twice_login(r, ply, c, zone_id);
		return;
	}

	struct ConnectionX * connX = rbtNet_get_x(c);
	connX->a1 = CONN_CLIENT;
	connX->a2 = account;

	ply = rbtF_player_init(r, c, account);
	ply->zone_id = zone_id;

	struct LogicalServer * serv = rbtF_get_serv_by_zone(r, zone_id);
	if(!serv) {
		kLOG(r, 0, "[LOG]玩家登陆，(Account:%d)登陆，没有这个服务器！ZoneID(%d) ip:%s, port:%d\n", account, zone_id, rbtNet_ip(c), rbtNet_port(c));
		return -1;
	}

	struct Zone * zone = rbtF_get_zone(r, zone_id);
	if(!zone) {
		kLOG(r, 0, "[LOG]玩家登陆，(Account:%d)登陆，没有这个Zone！ZoneID(%d) ip:%s, port:%d\n", account, zone_id, rbtNet_ip(c), rbtNet_port(c));
		return -1;
	}

	zone->nuser++;

	serv->nuser++;

	G(r)->nuser++;
	
	Packet * pkt_t = rbtP_init(r);
	rbtP_set_fun(pkt_t, SERVER_ENTER_ZONE | PKT_FUN_MASK);
	rbtP_writeInt(pkt_t, account);
	rbtP_writeInt(pkt_t, zone_id);

	rbtF_send_serv(r, serv->id, pkt_t);

	rbtP_drop(pkt_t);

	kLOG(r, 0, "[LOG]玩家登陆成功 ip:%s, port:%d，Account(%d), ZoneID(%d) Zone总人数:%d, ServID(%d) Serv总人数:%d，总人数:%d\n",
			rbtNet_ip(c), rbtNet_port(c), account, zone_id, zone->nuser, serv->id, serv->nuser, G(r)->nuser);

	return 0;*/
}

int rbtF_rpc_process( rabbit * r, Connection * c, int fun, Packet * pkt )
{
	struct ConnectionX * connX = rbtNet_get_x(c);

	if(!connX->a1) {
		if(fun == CONN_FOR_SERVER_REGISTER) {
			return serv_reg(r, c, pkt);
		}
		if(fun == CONN_FOR_ADMIN_REGISTER) {
			return admin_reg(r, c, pkt);
		}


		int tmp = (fun >> 8) & 0x1F;
		if(tmp == CLIENT_LOGIN) {

			if(rbtP_size(pkt) > 1024) {
				// 登录数据包不能超过1K
				kLOG(r, 0, "[Error]登录数据包过大(%d)!\n", rbtP_size(pkt));
				return -1;
			}

			return client_login(r, c, pkt);
		}

		kLOG(r, 0, "[Error]未验证之前发起RPC调用(%d)\n", fun);
		return -1;
	}

	if(connX->a1 == CONN_ADMIN) {
		if(c == G(r)->admin) {
			rbtF_rpc_admin(r, c, fun, pkt);
		}
		return 0;
	}

	if(connX->a1 == CONN_SERV) {
		struct LogicalServer * serv = rbtF_get_serv(r, connX->a2);
		if(!serv) {
			kLOG(r, 0, "[Error]链接发送数据，关联服务器（%d），不存在！\n", connX->a2);
			return -1;
		}
		serv->stat.npkt_recv++;
		serv->stat.recv_size += rbtP_size(pkt);

		return rbtF_rpc_server(r, c, fun, pkt);
	}

//	assert(connX->a1 == CONN_CLIENT);
	if(connX->a1 != CONN_CLIENT) {
		kLOG(r, 0, "[Error] 未知的链接类型:%d\n", connX->a1);
		return -1;
	}

	G(r)->stat.npkt_recv++;
	G(r)->stat.recv_size += rbtP_size(pkt);

	struct Player * ply = rbtF_player_get_account(r, connX->a2);

	if(!ply) {
		kLOG(r, 0, "[Error]链接发送数据，关联玩家（%d），不存在！\n", connX->a2);
		return -1;
	}

	ply->stat.npkt_recv++;
	ply->stat.recv_size += rbtP_size(pkt);

	if(ply->state != E_PlayerState_OK) {
		kLOG(r, 0, "[Error]玩家(account:%d)发送数据，但是这个玩家不是OK状态！\n", connX->a2);
		return 0;
	}

	return rbtF_rpc_client(r, c, fun, pkt);
}

